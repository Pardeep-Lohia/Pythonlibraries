# 4W1H: What, Why, When, Where, How of pathlib

## What is pathlib?
`pathlib` is Python's object-oriented module for handling filesystem paths. It provides Path classes that represent filesystem paths as objects rather than strings, enabling more intuitive and robust path manipulations.

### Key Components
- **Path Objects**: Immutable objects representing file or directory paths
- **Pure Paths**: Abstract path operations without filesystem access
- **Concrete Paths**: Path objects with filesystem interaction capabilities

## Why Use pathlib?
### Advantages Over Traditional Approaches
- **Readability**: Code reads like natural language (e.g., `path / 'subdir'`)
- **Cross-Platform**: Automatic handling of OS-specific path separators
- **Type Safety**: Path objects prevent common string concatenation errors
- **Method Chaining**: Fluent interface for complex path operations
- **Error Reduction**: Built-in validation and normalization

### Real-World Scenario: Configuration File Management
**Problem**: A cross-platform application needs to locate and read configuration files from user directories.

**Traditional Approach**:
```python
import os
config_path = os.path.join(os.path.expanduser('~'), '.myapp', 'config.ini')
```

**pathlib Approach**:
```python
from pathlib import Path
config_path = Path.home() / '.myapp' / 'config.ini'
```

The pathlib version is clearer, more concise, and automatically handles platform differences.

## When to Use pathlib?
### Ideal Use Cases
- **File System Operations**: Reading, writing, moving, or deleting files/directories
- **Path Construction**: Building complex paths from components
- **Cross-Platform Development**: Applications that run on Windows, macOS, and Linux
- **Script Automation**: Batch processing of files or directories
- **Configuration Management**: Locating user-specific or application-specific paths

### When NOT to Use pathlib
- **Legacy Code Integration**: When working with existing codebases heavily using `os.path`
- **Performance-Critical Operations**: For extremely high-performance requirements (though difference is minimal)
- **Simple String Operations**: For basic string manipulations without filesystem interaction

## Where Does pathlib Fit in Python Ecosystem?
### In Relation to Other Modules
- **os.path**: String-based path operations (pathlib is preferred for new code)
- **os**: Low-level OS interface (pathlib provides higher-level abstraction)
- **shutil**: High-level file operations (works seamlessly with pathlib)
- **glob**: Pattern matching (pathlib has built-in globbing)

### Integration Points
```python
import shutil
from pathlib import Path

# pathlib integrates well with other modules
src = Path('source.txt')
dst = Path('destination.txt')
shutil.copy(src, dst)  # shutil accepts Path objects
```

## How Does pathlib Work?
### Basic Usage Pattern
1. **Import**: `from pathlib import Path`
2. **Create**: `path = Path('some/directory/file.txt')`
3. **Manipulate**: Use methods like `path.parent`, `path.name`, `path.suffix`
4. **Operate**: Perform filesystem operations with `path.exists()`, `path.read_text()`, etc.

### Real-World Scenario: Log File Rotation
**Scenario**: A logging system needs to rotate log files daily, creating backups with timestamps.

```python
from pathlib import Path
from datetime import datetime

def rotate_log(log_file: Path):
    """Rotate a log file by creating a timestamped backup."""
    if log_file.exists():
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_name = f"{log_file.stem}_{timestamp}{log_file.suffix}"
        backup_path = log_file.parent / backup_name
        log_file.rename(backup_path)
        # Create new empty log file
        log_file.touch()

# Usage
log_path = Path('/var/log/myapp.log')
rotate_log(log_path)
```

### Advanced Pattern: Recursive Directory Processing
```python
from pathlib import Path

def process_project_files(project_root: Path):
    """Process all Python files in a project recursively."""
    for py_file in project_root.rglob('*.py'):
        print(f"Processing: {py_file}")
        # Perform operations on each Python file

# Usage
project = Path('/path/to/my/project')
process_project_files(project)
```

## Summary
`pathlib` transforms path handling from error-prone string operations to intuitive object-oriented programming. It excels in cross-platform development, improves code readability, and integrates seamlessly with Python's ecosystem. Whether building simple scripts or complex applications, `pathlib` provides the tools for robust filesystem interactions.
