# 4W1H: What, Why, When, Where, How of `shutil`

## What is `shutil`?
`shutil` is Python's built-in module for high-level file and directory operations. It provides functions to copy, move, rename, and remove files and directories, as well as utilities for archiving and disk usage inspection. Unlike low-level modules like `os`, `shutil` offers convenient, cross-platform functions for common file system tasks.

## Why Use `shutil`?
`shutil` simplifies file operations that would otherwise require complex, error-prone code using lower-level modules. It handles platform differences automatically, provides robust error handling, and offers performance optimizations for bulk operations. It's essential for:
- Reducing boilerplate code in file management scripts
- Ensuring cross-platform compatibility
- Avoiding common pitfalls in file operations
- Building reliable automation tools

## When to Use `shutil`?
Use `shutil` when you need to:
- **Copy files or directories**: For backups, deployments, or data migration
- **Move or rename files**: During file organization or refactoring
- **Create archives**: For packaging applications or compressing data
- **Remove directory trees**: For cleanup operations
- **Check disk usage**: For monitoring storage consumption
- **Build file management utilities**: Scripts for batch processing

Avoid `shutil` for:
- Simple file existence checks (use `os.path` or `pathlib`)
- Basic path manipulations (use `pathlib`)
- Low-level file I/O (use built-in `open()`)

## Where is `shutil` Used?
`shutil` is used in various contexts:
- **System administration scripts**: Automating backups and cleanup
- **Build tools**: Copying files during compilation/deployment
- **Data processing pipelines**: Moving and organizing data files
- **Application installers**: Setting up directory structures
- **Development tools**: Project scaffolding and file management
- **Web applications**: Handling file uploads and downloads

## How Does `shutil` Work?
`shutil` builds on top of lower-level modules like `os` and provides high-level abstractions:

```python
import shutil
import os

# High-level copy (shutil)
shutil.copy('source.txt', 'destination.txt')

# Equivalent low-level operations (os)
with open('source.txt', 'rb') as src, open('destination.txt', 'wb') as dst:
    dst.write(src.read())
os.chmod('destination.txt', os.stat('source.txt').st_mode)
```

### Key Concepts:
- **Atomic operations**: Many functions ensure data integrity
- **Recursive operations**: Handle directory trees automatically
- **Metadata preservation**: Copies permissions, timestamps, etc.
- **Cross-platform compatibility**: Works on Windows, macOS, Linux

## Real-World Scenarios

### Scenario 1: Automated Backup
```python
# Backup a user's documents folder
import shutil
from pathlib import Path

def backup_documents():
    source = Path.home() / 'Documents'
    backup_dir = Path.home() / 'Backup'
    backup_dir.mkdir(exist_ok=True)

    # Copy entire directory tree
    shutil.copytree(source, backup_dir / 'Documents_backup')
```

### Scenario 2: Project Deployment
```python
# Deploy web application files
def deploy_app(source_dir, target_dir):
    # Copy only necessary files, preserving structure
    shutil.copytree(source_dir, target_dir, ignore=shutil.ignore_patterns('*.pyc', '__pycache__'))
```

### Scenario 3: Log Rotation
```python
# Archive old log files
def rotate_logs(log_dir, archive_dir):
    for log_file in Path(log_dir).glob('*.log'):
        if log_file.stat().st_size > 1000000:  # 1MB
            # Move to archive and compress
            shutil.move(str(log_file), str(archive_dir))
            shutil.make_archive(str(archive_dir / log_file.stem), 'zip', archive_dir, log_file.name)
```

These scenarios demonstrate how `shutil` enables efficient, reliable file operations in automation and system management tasks.
